import 'package:flutter/material.dart';

import 'package:activity_ring/activity_ring.dart';

/// A helper class to fetch paints easily
class RingPaints {
  // ignore: public_member_api_docs
  const RingPaints({
    this.arcPaint,
    this.initialCirclePaint,
    this.finalCirclePaint,
  });

  /// Main arc and ring painter
  final Paint? arcPaint;

  /// Painter for circle at the beginning
  final Paint? initialCirclePaint;

  /// Painter for circle at the end
  final Paint? finalCirclePaint;
}

/// Color scheme for painting progress rings.
///
/// A single color scheme will be used by a [Ring]. You can provide only one of
/// the parameters. The order of precedence when multiple params are availble is
/// [ringGradients] > [ringColors] > [ringGradient] > [ringColor].
/// When single color params([ringColor], [ringColors]) are provided if
/// [gradient] is `true` then the end color for the ring will be brightened
/// by [intensity]%.
///
/// When painting for unavailable nth number ring is required, the colors will
/// be interpolated from the last element in the list.
/// For subsequent rings where color is not available, when gradient is true
/// then end color of previous ring is used as start color for this ring and
/// end color for this ring is generated by brightening of start color.
/// When gradient is false, start color is obtained by brightening
/// previous ring color, then this ring is painted with same color
/// For more explanation and examples, read property documentation.
class RingColorScheme {
  // ignore: public_member_api_docs
  RingColorScheme({
    this.ringGradients,
    this.ringColors,
    this.ringGradient,
    this.ringColor,
    this.backgroundColor,
    this.gradient = true,
    this.intensity = 20,
    this.maxNumRing = 3,
  })  : assert(
          ringGradients != null ||
              ringColors != null ||
              ringGradient != null ||
              ringColor != null,
          'Provide one of ringGradients, ringColors, ringGradient or ringColor',
        ),
        _colors = _generateRingColors(
          ringGradients: ringGradients,
          ringGradient: ringGradient,
          ringColors: ringColors,
          ringColor: ringColor,
          gradient: gradient,
          intensity: intensity,
          maxNumRing: maxNumRing,
        );

  /// Creates ring colors from a list of list of colors
  ///(gradient will be forcefully switched to true).
  ///
  /// This list of colors is used for painting the available gradients.
  /// Note: For consistency, give same color for last color in (n-1) ring
  /// and first color in the nth ring.
  /// Example: (gradient will be forcefully switched to true)
  /// `ringGradients = [[a,b], [b,c]]`
  /// 1st ring -> Gradient of a->b
  /// 2nd ring -> Gradient of b->c
  /// 3rd ring -> Gradient of c->brighten(c)
  /// 4th ring -> Gradient of brighten(c)->brighten(c, 2x)..
  final List<List<Color>>? ringGradients;

  /// Creates a ring color from a single color based on position of color.
  ///
  /// If [gradient], then end color is genretaed by brightening start color
  /// by intensity %. Else, Color of ring will be same.
  /// Example:
  /// `ringColors = [a, b]; gradient=true`
  /// 1st ring -> Gradient of a->brighten(a)
  /// 2nd ring -> Gradient of b->brighten(b)
  /// 3rd ring -> Gradient of brighten(b)->brighten(b, 2x)..
  /// `ringColors = [a, b]; gradient=false`
  /// 1st ring -> a
  /// 2nd ring -> b
  /// 3rd ring -> brighten(b)..
  final List<Color>? ringColors;

  /// Creates ring colors from a list of colors
  /// (gradient will be forcefully switched to true).
  ///
  /// This list of colors is used for painting the first ring. For subsequent
  /// rings, start color will be last color in previous ring(for consistency).
  /// Example:
  /// `ringGradient = [a,b]`
  /// 1st ring -> Gradient of a->b
  /// 2nd ring -> Gradient of b->brighten(b)
  /// 3rd ring -> Gradient of brighten(b)->brighten(b, 2x)..
  final List<Color>? ringGradient;

  /// Creates ring colors from a single color.
  ///
  /// If [gradient], then both start(only for > second ring) and end color's of
  /// ring are brightened by intensity %. Else, Color of ring will be consistent
  /// and next ring layer will be brightened by intensity %.
  /// Example:
  /// `ringColor = a; gradient=true`
  /// 1st ring -> Gradient of a->brighten(a)
  /// 2nd ring -> Gradient of brighten(a)->brighten(a, 2x)..
  /// `ringColors = a; gradient=false`
  /// 1st ring -> a
  /// 2nd ring -> brighten(a)
  /// 3rd ring -> brighten(a, 2x)..
  final Color? ringColor;

  /// Color of background ring on which progress is drawn.
  ///
  /// If null then darken(ringColor, 85) is used.
  /// Note: background ring will only be shown if showBackground is true.
  final Color? backgroundColor;

  /// True if the ring's color should change like gradient.
  final bool gradient;

  /// Percentage of intensity for brightening ring colors.
  final double intensity;

  /// Maximum color gradients to cache for this scheme.
  final int maxNumRing;

  /// Paint for background ring.
  ///
  /// Creates a background ring paint with [width] of the ring
  /// Since this stays out of animation, we dont need to cache this.
  Paint backgroundRingPaint(double width) {
    final _ringBackgroundColor =
        backgroundColor ?? darken(colors.first.first, 85);
    return Paint()
      ..color = _ringBackgroundColor
      ..strokeWidth = width
      ..style = PaintingStyle.stroke;
  }

  List<List<Color>> _colors;

  /// Get Colors for painting rings.
  List<List<Color>> get colors => _colors;

  /// Helper metchod to create end color of a ring based on gradient
  static Color _getEndColor(
    bool gradient,
    double intensity,
    Color firstColor,
  ) {
    if (gradient) {
      return brighten(firstColor, intensity);
    }
    return firstColor;
  }

  static List<List<Color>> _generateRingColors({
    required List<List<Color>>? ringGradients,
    required List<Color>? ringColors,
    required List<Color>? ringGradient,
    required Color? ringColor,
    required bool gradient,
    required double intensity,
    required int maxNumRing,
  }) {
    // ignore: omit_local_variable_types
    List<List<Color>> colors = [];

    if (ringGradients != null) {
      if (ringGradients.length >= maxNumRing) {
        // nothing to do here.
        return ringGradients;
      }
      colors = ringGradients;

      for (var i = colors.length; i <= maxNumRing; i++) {
        colors.add([
          colors.last.last,
          _getEndColor(gradient, intensity, colors.last.last),
        ]);
      }
      return colors;
    } else if (ringColors != null) {
      Color startColor;
      Color endColor;
      for (var i = 0; i < maxNumRing; i++) {
        if (ringColors.length > i) {
          startColor = ringColors.elementAt(i);
          endColor = _getEndColor(gradient, intensity, startColor);
        } else {
          startColor = brighten(
            ringColors.last,
            (i - ringColors.length + 1) * intensity,
          );
          endColor = _getEndColor(gradient, intensity, startColor);
        }
        colors.add([startColor, endColor]);
      }
    } else if (ringGradient != null) {
      Color startColor;
      Color endColor;

      colors.add(ringGradient);

      // Start from 1 as we manually added first ring gradient
      for (var i = 1; i < maxNumRing; i++) {
        startColor = brighten(ringGradient.last, (i - 1) * intensity);
        endColor = _getEndColor(gradient, intensity, startColor);
        colors.add([startColor, endColor]);
      }
    } else if (ringColor != null) {
      Color startColor;
      Color endColor;
      for (var i = 0; i < maxNumRing; i++) {
        startColor = brighten(ringColor, i * intensity);
        endColor = _getEndColor(gradient, intensity, startColor);
        colors.add([startColor, endColor]);
      }
    }
    return colors;
  }

  /// Update generated colors for more rings.
  ///
  /// If [maxNumRing] is < existing colors length then no processing happens.
  void updateRingColors([
    int maxNumRing = 3,
  ]) {
    // Since colors and all color variables are final
    if (maxNumRing <= _colors.length) {
      return;
    }
    _colors = _generateRingColors(
      ringGradients: ringGradients,
      ringColors: ringColors,
      ringGradient: ringGradient,
      ringColor: ringColor,
      gradient: gradient,
      intensity: intensity,
      maxNumRing: maxNumRing ?? this.maxNumRing,
    );
  }

  // ---------------------------------------------------------------------------
  // Variables required to create paints for caching paints
  /// Center of ring
  Offset? _center;

  /// Width of ring
  double? _width;
  // ---------------------------------------------------------------------------

  /// A cache variable to store color for this scheme
  Color? _first;

  /// Get first color from first ring. Also store the result of first run
  /// to a cache variable.
  Color? get first => _first ??= ringGradients?.first?.first ??
      ringColors?.first ??
      ringGradient?.first ??
      ringColor;

  /// A cache variable to store paints for rings
  List<RingPaints>? _paints;

  /// Generate paints for caching
  void setPaints(Offset center, double width) {
    if (center == _center || width == _width) {
      if (_paints != null) {
        return;
      }
    }
    _center = center;
    _width = width;

    _paints = [];

    for (var i = 0; i < _colors.length; i++) {
      final initialCirclePaint = Paint()..color = _colors[i].first;
      final finalCirclePaint = Paint()..color = _colors[i].last;

      final shader = SweepGradient(
        colors: _colors[i],
        tileMode: TileMode.repeated,
        startAngle: degreeToRadians(270),
        endAngle: degreeToRadians(270 + 360.0),
      ).createShader(
        Rect.fromCircle(
          center: center,
          radius: 0,
        ),
      );

      final arcPaint = Paint()
        ..strokeCap = StrokeCap.round
        ..style = PaintingStyle.stroke
        ..strokeWidth = width
        ..shader = shader;

      _paints!.add(RingPaints(
        initialCirclePaint: initialCirclePaint,
        arcPaint: arcPaint,
        finalCirclePaint: finalCirclePaint,
      ));
    }
  }

  /// Get cached paints
  List<RingPaints>? getPaints(Offset center, double width) {
    if (center == _center || width == _width) {
      if (_paints != null) {
        return _paints;
      }
    }
    setPaints(center, width);

    return _paints;
  }

  /// Get cached paints for [ringNum] ring.
  RingPaints getCirclePaints(int ringNum, Offset center, double width) {
    return getPaints(center, width)!.elementAt(ringNum - 1);
  }

  /// Get which value should be used for coloring paint.
  String? get mode {
    if (ringGradients != null) {
      return 'ringGradients';
    } else if (ringColors != null) {
      return 'ringColors';
    } else if (ringGradient != null) {
      return 'ringGradient';
    } else if (ringColor != null) {
      return 'ringCOlor';
    } else {
      return null;
    }
  }
}
